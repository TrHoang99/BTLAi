# -*- coding: utf-8 -*-
"""LicensePlate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CJILwU83SWpUnnbyBCG18Q40bVfD-2PH
"""

!git clone https://github.com/thangnch/MiAI_LP_Detection_2

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/MiAI_LP_Detection_2

"""#CNN digit classification"""

!gdown https://drive.google.com/u/0/uc?id=156hRgdmD2gR_vdW3OtJmS_reFRMpXQ42&export=download



!unzip data.zip

!mkdir model_save

from tensorflow.keras import optimizers
from tensorflow.keras.models import Sequential
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Dense, Flatten, MaxPooling2D, Dropout, Conv2D
import tensorflow as tf

train_gen = ImageDataGenerator(rescale=1/255.,
                               rotation_range=0.1,
                               width_shift_range=0.1,
                               height_shift_range=0.1)
val_gen = ImageDataGenerator(rescale=1/255.)

train_dataset = train_gen.flow_from_directory("data/train", target_size=(28, 28))
val_dataset = val_gen.flow_from_directory("data/val", target_size=(28, 28))

###CNN model
model = Sequential()
model.add(Conv2D(64, 5, input_shape=(28, 28, 3), activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(32, 5, activation='relu', padding='same'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.4))

model.add(Dense(36, activation='softmax'))

model.compile(loss='categorical_crossentropy', optimizer=optimizers.Adam(learning_rate=0.0001), metrics=["acc"])
model.summary()

history = model.fit(train_dataset,
                    epochs=50,
                    validation_data=val_dataset,
                    callbacks=[tf.keras.callbacks.ModelCheckpoint("model_save", save_best_only=True), tf.keras.callbacks.EarlyStopping(patience=5)],
                    verbose=1)

import matplotlib.pyplot as plt
plt.plot(history.history["acc"], c="r", label="train_acc")
plt.plot(history.history["val_acc"], c="g", label="val_acc")
plt.legend()
plt.show()

plt.plot(history.history["loss"], c="r", label="train_loss")
plt.plot(history.history["val_loss"], c="g", label="val_loss")
plt.legend()
plt.show()

"""# Detect biển số 

"""

import cv2
from google.colab.patches import cv2_imshow
from lib_detection import load_model, detect_lp, im2single
import numpy as np

# Load model LP detection
wpod_net_path = "wpod-net_update1.json"
wpod_net = load_model(wpod_net_path)

# Đường dẫn ảnh, các bạn đổi tên file tại đây để thử nhé
img_path = "/content/MiAI_LP_Detection_2/test/test.jpg"

# Đọc file ảnh đầu vào
Ivehicle = cv2.imread(img_path)
cv2_imshow(Ivehicle)
cv2.waitKey(0)


# Kích thước lớn nhất và nhỏ nhất của 1 chiều ảnh
Dmax = 608
Dmin = 288

# Lấy tỷ lệ giữa W và H của ảnh và tìm ra chiều nhỏ nhất
ratio = float(max(Ivehicle.shape[:2])) / min(Ivehicle.shape[:2])
side = int(ratio * Dmin)
bound_dim = min(side, Dmax)

_ , LpImg, lp_type = detect_lp(wpod_net, im2single(Ivehicle), bound_dim, lp_threshold=0.5)


if (len(LpImg)):

    # Xử lý đọc biển đầu tiên, các bạn có thẻ sửa code để detect all biển số
    LpImg[0] = cv2.convertScaleAbs(LpImg[0], alpha=(255.0))
    cv2_imshow(cv2.cvtColor(LpImg[0],cv2.COLOR_RGB2BGR))
    cv2.waitKey()

gray = cv2.cvtColor(LpImg[0], cv2.COLOR_BGR2GRAY)

# Ap dung threshold de phan tach so va nen
binary = cv2.threshold(gray, 0, 255,
                       cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]
cv2_imshow(binary)

def CCA(image, plate):
    H, W = image.shape[:2]
    output = cv2.connectedComponentsWithStats(
        image, 2, cv2.CV_32S)
    (numLabels, labels, stats, centroids) = output
    bboxes = []
    for i in range(1, numLabels):
        x = stats[i, cv2.CC_STAT_LEFT]
        y = stats[i, cv2.CC_STAT_TOP]
        w = stats[i, cv2.CC_STAT_WIDTH]
        h = stats[i, cv2.CC_STAT_HEIGHT]
        if w * h < 50:
            continue
        if H / h > 10:
            continue
        if w > W // 2:
            continue
        if w > h:
            continue
        # if (y <= 10 or y + h > H - 10) and (x < 10 or x + w > W - 10):
        #     continue
        cv2.rectangle(plate, (x, y), (x + w, y + h), (0, 0, 255), 2)
        bboxes.append([x, y, w, h])
    return bboxes, plate

def add_extend(image, type="black", size=2):
    H, W = image.shape[:2]
    if type == "black":
        blank_image = np.zeros((H + size * 2, W + size * 2), np.uint8)
    elif type == "white":
        blank_image = np.full((H + size * 2, W + size * 2), 255, np.uint8)
    blank_image[size:H + size, size:W + size] = image
    return blank_image

plate_copy = LpImg[0].copy()
bboxes, plate = CCA(binary, plate_copy)
cv2_imshow(plate)

import string
class_name = string.digits + string.ascii_uppercase

def fix_dimension(img): 
  new_img = np.zeros((28,28,3))
  for i in range(3):
    new_img[:,:,i] = img
  return new_img

"""# Digit recognition"""

extend = 1
images = []
labels = []
for x, y, w, h in bboxes:
    crop = binary[y - extend:y + h + extend, x - extend:x + w + extend]
    crop = add_extend(crop)
    crop = cv2.erode(crop, np.ones((3, 3)))
    crop = cv2.resize(crop, (28, 28))
    images_crop = fix_dimension(crop)
    images_crop = np.array([images_crop])
    y_hat = model.predict(images_crop)
    # print(y_hat)
    prediction = np.argmax(y_hat, axis=-1)[0]
    images.append(crop)
    labels.append(class_name[prediction])
    print(class_name[prediction])
    cv2_imshow(crop)

import numpy as np
import matplotlib.pyplot as plt

w = 4
h = 4
fig = plt.figure(figsize=(15, 15))
columns = 4
rows = 5
for i in range(1, columns*rows + 1):
    try:
        img = images[i - 1]
        fig.add_subplot(rows, columns, i)
        plt.title(labels[i - 1])
        plt.xticks([])
        plt.yticks([])
        plt.imshow(img, cmap="gray")
    except:
        break
plt.show()

